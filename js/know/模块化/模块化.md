1.构造
2.实例化
3.求值

构造时：查找、下载并解析所有文件到模块记录中。
实例化：在内存中存储所有导出的变量（但还没有填充值）。让 export 和 import 都指向这些内存块。（linking）。
求值：运行代码，在内存块中填入变量的实际值。


## 1.构造过程
模块映射：全局的，用来管理模块缓存,亦可跟踪哪些文件正在被获取（module map）
         加载器开始获取一个 URL 时，它会将该 URL 放入模块映射中，并标记上它正在fetching
         http://example.com/main.js  |  fetching
         注：当别的模块也依赖同一个文件的时候，会查询映射里面的每一个URL，如果它看到这个URL有fetching的标志，那它就不管了，继续
            下一个URL的处理。

将获取到的文件解析为模块记录
模块映射：模块记录被创建，会被记录在模块映射中
         http://example.com/main.js  |  模块记录
         在这之后的任意时间如果有对它的请求，加载器就可以从映射中获取它


## 2.实例化过程
实例化这些模块
模块环境记录：它管理着模块记录的变量，为所有的 export 分配内存空间。
             模块环境记录会跟踪不同内存区域与不同 export 间的对应关系。
             一个模块记录对应一个模块环境记录

实例化模块图时
深度优先后序遍历：深入到模块图的底部 —— 直到不依赖于其他任何东西的底部 —— 并处理它们的 export
当JS引擎完成一个模块的所有导出的链接，它就会返回上一个层级去设置来自于这个模块的导入（import）。
需要注意的是，导出和导入都是指向同一片内存地址。先链接导出保证了所有的导入都能找到对应的导出。

“动态绑定”：ES module导出的模块和导入的模块都指向同一段内存地址。如果，导出模块修改了一个值，那么这个修改会在导入模块里面也得到体现。
导出值的模块可以随时更改这些值，但导入模块不能更改其导入的值。但是，如果一个模块导入一个对象，它可以改变该对象上的属性值。


## 3.求值
最后一步是在内存中填值。JS 引擎通过执行顶层代码 —— 函数之外的代码来实现这一点。
和实例化一样，求值也是按照深度优先倒序的规则来的。