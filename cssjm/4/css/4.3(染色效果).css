/* 为一幅灰度图片（或是被转换为灰度模式的彩色图片）增加染色效果（color tint），是一种流行且优雅的方式，可以给一系列风格迥异的照片带来
视觉上的一致性。我们通常会在静止状态下应用这个效果，当发生 :hover或其他交互时再去除。一直以来，我们需要使用图像处理软件来生成图片的两
个版本，然后再写一些简单的 CSS 代码来处理这两个版本的交替显现。这个方法行得通，但它会导致更大的文件体积和额外的 HTTP 请求，而且在可维
护性方面也是一场噩梦。想像一下，一旦我们决定改变这个效果的主色调，就不得不处理所有的图片，为它们重新制作全套的单色版本！ */
/* 另外一种方法是：在图片的上层覆盖一层半透明的纯色；或者把图片设置为半透明并覆盖在一层实色背景之上。但这其实并不是真正的染色效果：不仅
没有把图片中的各种颜色转换为目标色调，同时也极大地削弱了图片的对比度。此外还有基于 JavaScript 的方案，把图片置入 <canvas> 元素中，并利
用脚本对其进行染色处理。这确实可以得到真实的染色效果，但性能不佳，而且限制很多。难道就没有一种更简单的、纯 CSS 的方法能实现图片染色效果
吗？ */
/* 由于没有一种现成的滤镜是专门为这个效果而设计的，我们需要花一些心思，把多个滤镜组合起来。我们要使用的第一个滤镜是 sepia()，它会给图片
增加一种降饱和度的橙黄色染色效果，几乎所有像素的色相值会被收敛到 35~40。如果这种色调正是我们想要的，那就可以收工了。不过我们的需求通常并
非如此。如果我们想要的主色调的饱和度比这更高，可以用 saturate() 滤镜来给每个像素提升饱和度。假设我们想要的主色调是 hsl(335, 100%, 50%)
，那就需要把饱和度提升一些，于是我们将饱和度参数设置为 4。具体取值取决于实际情况，我们通常需要用肉眼来观察和判断。这两个滤镜的组合会让我们
的图片具有一种暖金色的染色效果。图片现在看起来很不错，但我们并不希望把图片调为这种橙黄色调，而是稍深的亮粉色。因此，我们还需要再添加一个
 hue-rotate() 滤镜，把每个像素的色相以指定的度数进行偏移。为了把原有的色相值 40 改变为 335，我们需要增加大约 295 度（335 – 40）： */

/* .root {
  filter: sepia(1) saturate(4) hue-rotate(295deg);
} */

/* 此时，我们就把这张图片的色调改变了。如果这个效果需要由 :hover 或其他状态来触发切换，我们甚至还可以为这个变化增加过渡动画 */
/* img {
  transition: .5s filter;
  filter: sepia(1) saturate(4) hue-rotate(295deg);
 }
img:hover,
img:focus {
  filter: none;
} */

/* 混合模式法 */
/* 滤镜方案是行之有效的，但你可能会注意到它产生的结果与我们在图像处理软件中得到的效果不完全一致。即使我们想把图像调为一种很亮的颜
色，结果仍然会显得像褪了色一般。如果尝试在 saturate() 滤镜中增加饱和度，又会得到一种不自然的、过度风格化的效果。不过，幸好我们还有另
一种更好的实现方法——混合模式！如果用过 Adobe Photoshop 这样的图像处理软件，那你可能已经对混合模式相当熟悉了。当两个元素叠加时，“混合
模式”控制了上层元素的颜色与下层颜色进行混合的方式。用它来实现染色效果时，需要用到的混合模式是 luminosity。这种 luminosity 混合模式会
保留上层元素的 HSL 亮度信息，并从它的下层吸取色相和饱和度信息。如果在下层准备好我们想要的主色调，并把待处理的图片放在上层并设置为这种混
合模式，那本质上不就是在做染色处理吗？要对一个元素设置混合模式，有两个属性可以派上用场：mix-blendmode 可以为整个元素设置混合模式，bac
kground-blend-mode 可以为每层背景单独指定混合模式。这意味着，如果用这个方案来处理图片，我们实际上有两种选择。不过这两者各有所短。
 第一种选择：需要把图片包裹在一个容器中，并把容器的背景色设置为我们想要的主色调。
 第二种选择：不用图片元素，而是用 <div> 元素——把这个元素的第一层背景设置为要染色的图片，并把第二层的背景设置为我们想要的主色调。
针对不同的场景，可以选择这两者的其中之一。举个例子，如果我们希望对一个 <img> 元素应用这个效果，就需要把它包含在另一个元素内部。不
过如果我们已经有了这一层容器，比如a，那就水到渠成了： */
/* 。。。。。 */

a {
  display: inline-block;
  background: hsl(335, 100%, 50%);
  line-height: 0px;
}

img {
  mix-blend-mode: luminosity;
}

/* 与CSS 滤镜类似，混合模式可以平稳退化：如果不被支持，效果只是不出现而已，图片本身还是完好可见的。有一件事情需要注意，滤镜是可动画的，
而混合模式则不是。我们在上面已经见识过了，一张图片只需要在 filter 属性上设置好 CSS 过渡之后就可以从全彩样式慢慢淡化为单色样式，但你无
法对混合模式做同样的事情。不过也别着急，这并不表示过渡动画是完全不可能的，只是意味着我们需要跳出框框来重新思考。如上面所解释的那样，mi
x-blend-mode 是把整个元素向下进行混合，而不管它的下层是什么。因此，如果我们把这个属性设置为 luminosity 混合模式，那图片就总是会跟某
些东西进行混合。此外，使用 backgroundblend-mode 属性则可以让每层背景跟它的下层背景进行混合，但并不关心元素之外是什么情况。另外，当我
们只有一个背景图像以及一个透明背景色时，会发生什么？你猜对了：不会出现任何混合效果！好的，接下来我们将利用上述分析结果，采用 backgroun
d-blendmode 属性来达成我们想要的效果。在此之前，HTML 代码需要稍作调整： */
.tinted-image {
  width: 140px;
  height: 140px;
  background-repeat: round;
  background-color: hsl(335, 100%, 50%);
  background-blend-mode: luminosity;
  transition: .5s background-color;
}
.tinted-image:hover {
  background-color: transparent;
}
/* 不过，就像前面提到的那样，这两种方法都不够理想。它们的主要问题在于：
 图片的尺寸需要在 CSS 代码中写死；
 在语义上，这个元素并不是一张图片，因此并不会被读屏器之类的
设备读出来。生活就是这样，没有十全十美。在这一节中，我们收获了三种实现染色效果的方法，每种方法都各有优缺点。到底选择哪种方法，还是要看
项目的具体需求。 */