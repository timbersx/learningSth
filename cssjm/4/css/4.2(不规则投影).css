/* 当我们想给一个矩形或其他能用 border-radius 生成的形状（在“自适应的椭圆”一节中可以看到一些示例）加投影时，box-shadow 的表现都
堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分。这类情况包括*/
/* 
 半透明图像、背景图像、或者 border-image（比如老式的金质像框）；
 元素设置了点状、虚线或半透明的边框，但没有背景（或者当background-clip 不是 border-box 时）；
 对话气泡，它的小尾巴通常是用伪元素生成的；
 我们在“切角效果”一节中见过的切角形状；
 几乎所有的折角效果，包括“折角效果”一节将提到的例子；
 通过 clip-path 生成的形状，比如“菱形图片”一节中提到的菱形图像。
*/

.root {
  width: 100px;
  height: 100px;
  padding: 20px;
  border: dashed 10px yellowgreen;
  border-radius: 20px;
  /* background-color: deepskyblue; */
  /* background-clip: padding-box; */
  /* box-shadow: 2px 2px 3px; */
}

/* 滤镜效果规范（http://w3.org/TR/filter-effects）为这个问题提供了一个解决方案。它引入了一个叫作 filter 的新属性，这个属性也是从
 SVG 那里借鉴过来的。尽管 CSS 滤镜基本上就是 SVG 滤镜，但我们并不需要掌握任何SVG 知识。相反，只需要一些函数就可以很方便地指定滤镜效
 果了，比如blur()、grayscale() 以及我们需要的 drop-shadow() ！如果你喜欢，甚至可以把多个滤镜串连起来，只要用空格把它们分隔开就可以
 了，比如： */
/* .root {
  filter: drop-shadow(2px 2px 3px rgba(0,0,0,.5));
} */

/* CSS 滤镜最大的好处在于，它们可以平稳退化：当浏览器不支持时，不会出现问题，只不过没有任何效果而已。如果你确实需要这个效果在尽可
能多的浏览器中显示出来，可以同时附上一个 SVG 滤镜，这样可以得到稍微好一些的浏览器支持度。你可以在滤镜效果规范（http://www.w3.org/TR/
filter-effects/）中为每个滤镜函数找到对应的 SVG 滤镜版本。你可以把 SVG滤镜和简化的 CSS 滤镜放在一起使用，让层叠机制来决定哪一行最终生
效： */
.root {
  /* filter: url(drop-shadow.svg#drop-shadow); */
  filter: drop-shadow(2px 2px 3px rgba(0,0,0,.5));
}

/* 不幸的是，如果 SVG 滤镜是存放在一个独立文件里的，那它就无法像一个简洁易用的函数那样在 CSS 代码中进行随意配置；如果它是内联的，则又
会搅乱你的代码。参数需要写死在文件内部，因此每当我们新加一种哪怕是大同小异的投影效果时，都需要多准备一个文件，这显然是难以接受的。当然，
我们还可以使用 data URI（它也会省掉额外的 HTTP 请求），但这个方法仍然会带来文件体积的增长。总的来说，这个方法只是一种回退方案，因此只
要我们把SVG 滤镜控制在一定数量以内，哪怕它们的效果大同小异，也是说得过去的。另外一件需要牢记的事情就是，任何非透明的部分都会被一视同仁
地打上投影，包括文本（如果背景是透明的），正如我们刚刚看到的那样。你可能会想，是不是可以通过 text-shadow: none; 来取消掉文本上的投影呢
？其实 text-shadow 跟它是完全不相干的两码事，因此这样做并不能取消文本上的 drop-shadow() 效果。此外，如果你已经用 textshadow 在文本上
加了投影效果，文本投影还会被 drop-shadow() 滤镜再加上投影，这本质上是给投影打了投影！ */
