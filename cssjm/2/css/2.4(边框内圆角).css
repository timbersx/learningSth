/* 有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状。这是一个有趣的效果，目前还没
有被滥用。用两个元素可以实现这个效果，这并没有什么特别的： */
.test-for24 {
  /* background: #655; */
  padding: .8em;
}
.test-for24 > div {
  background: tan;
  border-radius: .8em;
  padding: 1em;
}

/* 这个方法很好，但要求我们使用两个元素，而我们只需要一个元素。有没有办法可以只用一个元素达成同样的效果呢？ */
/* 其实上述方案要更加灵活一些，因为它允许我们充分运用背景的能力。举个例子，如果我们希望这一圈“边框”不只是纯色的，而是要加一层淡淡
的纹理，它也可以很容易地做到。不过，如果只需要达成简单的实色效果，那我们就还有另一条路可走，只需用到一个元素（但这个办法有一些 hack
的味道）。我们来看看以下 CSS 代码： */
.test-for24 > div {
  background: tan;
  border-radius: .8em;
  padding: 1em;
  box-shadow: 0 0 0 .6em #655;
  outline: .6em solid #655;
}

/*
我们基本上受益于两个事实：描边并不会跟着元素的圆角走，但 box-shadow 却是会的。因此，如果我们把这两者叠加到一起，box-shadow 
会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。把投影和描边显示为不同的颜色，从而在视觉上提供了更清晰的解释。
请注意，我们为 box-shadow 属性指定的扩张值并不一定等于描边的宽度，我们只需要指定一个足够填补“空隙”的扩张值就可以了。事实上，指
定一个等于描边宽度的扩张值在某些浏览器中可能会得到渲染异常，因此我推荐一个稍小些的值。这又引出了另一个问题：到底多大的投影扩张值可以
填补这些空隙呢？ */
/* 
关于怎样用它来计算我们需要的最小扩张值，请看图2.4中图形化的解释。我们要做的就是把它稍微向上取个整，为了避免每次都要计算，你可以直接使用
圆角半径的一半，因为 根号2 - 1 < 0.5 。
 */
/* 请注意，该计算过程揭示了这个方法的另一个限制：为了让这个效果得以达成，扩张半径需要比描边的宽度值小，但它同时又要比 
 (根号2 −1)r 大（这里的 r 表示 border-radius）。这意味着，如果描边的宽度比 (根号2 −1)r 小，那我们是不可能用这个方法达成该效果的。
*/
.test-for24 > div {
  background: tan;
  border-radius: .8em;
  padding: 1em;
  box-shadow: 0 0 0 .4em #655;
  outline: .6em solid #655;
}

/* 描边太小，这种方法不可能做到 */
.test-for24 > div {
  background: tan;
  border-radius: 10em;
  padding: 1em;
  box-shadow: 0 0 0 .2em #655;
  outline: .2em solid #655;
}