/* 饼图在网页中的运用极为普遍，比如简单的统计图表、进度指示器、定时器等，不一而足。尽管如此，饼图在过去很长一段时期内完全无法通过
Web 技术创建出来，即便是最简单的两种颜色的形态也不例外。过去要实现饼图，要么动用一个外部的图像处理软件来为饼图中的多个值制作多张图
片，要么动用那些专门为复杂图表而设计的 JavaScript框架。尽管这件事情已经不像过去那样“难于上青天”，但也仍然不存在“一行代码万事大吉”
的捷径。不过总的来说，眼下已经有一些更便捷、更易维护的方法来实现饼图了。 */

/* 基于 transform 的解决方案 */
/* 这个方案在结构层面是最佳选择：它只需要一个元素作为容器，而其他部分是由伪元素、变形属性和 CSS 渐变来实现的。让我们先从一个简单的
元素开始：假设我们目前的需求是一个最简单的饼图，其展示的比率是固定的20%；稍后再来改进它的灵活性。我们首先把这个元素设置为一个圆形，
以它作为背景（参见图 3-50）： */
/* .root {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: greenyellow;
} */

/* 我们的饼图是绿色的（确切地说是 yellowgreen），并将采用棕色（ #655）来显示比率。我们首先可能会想到用斜向拉伸变形来处理比率扇
区，但稍加尝试就会发现，这其实是一条死胡同。于是我们换种思路，把圆形的左右两部分指定为上述两种颜色，然后用伪元素覆盖上去，通过旋转来
决定露出多大的扇区。为了把圆形的右半部分设置为棕色，我们要用到一个简单的线性渐变： */
.root {
  width: 150px;
  height: 150px;
  border-radius: 50%;
  background: greenyellow;
  background-image: linear-gradient(90deg, transparent 50%, #655 0);
}

/* 可以看到，其结果正是我们所需要的。接下来，我们可以继续设置伪元素的样式，让它起到遮盖层的作用： */
/* .root::before {
  content: '';
  display: block;
  margin-left: 50%;
  height: 100%;
} */

/* 可以在看到，我们的伪元素现在相对于整个饼图进行了重叠。不过现在还没有设置任何样式，它还起不到遮盖的作用：暂时只是一个透明
的矩形。在开始为它设置样式之前，我们还要再做一些观察和分析。我们希望它能遮盖圆形中的棕色部分，因此应该给它指定绿色背景。在这
里使用 background-color: inherit 声明可以避免代码的重复，因为我们希望它的背景色与其宿主元素保持一致。
 我们希望它是绕着圆形的圆心来旋转的，对它自己来说，这个点就是它左边缘的中心点。因此，我们应该把它的 transform-origin
设置为 0 50%，或者干脆写成 left。
 我们不希望它呈现出矩形的形状，否则它会突破整个饼图的圆形范围。因此要么给 .root 设置 overflow: hidden 的样式，要么给这个
伪元素指定合适的 border-radius 属性来把它变成一个半圆。综合上面的思路，这个伪元素的 CSS 就确定下来了 */

/* .root::before {
  content: '';
  display: block;
  margin-left: 50%;
  height: 100%;
  border-radius: 0 100% 100% 0 / 50%;
  background-color: inherit;
  transform-origin: left;
  transform: rotate(.2turn);
} */

/* 我们的饼图看起来就是图中的样子了。接下来，美好的事情即将发生！我们现在可以通过一个 rotate() 变形属性来让这个伪元素转起来。如
果我们要显示出 20% 的比率，我们可以指定旋转的值为 72deg（0.2 ×360 = 72），写成 .2turn 会更加直观一些。在图 3-54 中，你还可以看到其
他一些旋转值的情况。你可能以为这就大功告成了，但事实上我们才刚刚开了个头。我们的饼图在显示 0 到 50% 的比率时运作良好，但如果我们尝试
显示 60% 的比率时（比如指定旋转值为 .6turn 时）。不过也别泄气，我们一定能够排除万难修复这个问题！如果把 50%~100% 的比率看作另外一个
问题，我们就会发现，可以使用上述技巧的一个反向版本来实现这个范围内的比率：设置一个棕色的伪元素，让它在 0 至 .5turn 的范围内旋转。因此
，要得到一个 60% 比率的饼图，伪元素的代码可能是这样的： */
/* .root::before {
  content: '';
  display: block;
  margin-left: 50%;
  height: 100%;
  border-radius: 0 100% 100% 0 / 50%;
  background: #655;
  transform-origin: left;
  transform: rotate(.1turn);
} */

/* 你可以看到它的实际效果。由于已经找到了实现任意比率的方法，我们甚至可以用 CSS 动画来实现一个饼图从 0 变化到 100% 的动
画，从而得到一个炫酷的进度指示器： */
@keyframes spin {
  to { transform: rotate(.5turn); }
}
@keyframes bg {
 50% { background: #655; }
}
.root::before {
  content: '';
  display: block;
  margin-left: 50%;
  height: 100%;
  border-radius: 0 100% 100% 0 / 50%;
  background-color: inherit;
  transform-origin: left;
  animation: spin 3s linear infinite,
  bg 6s step-end infinite;
}

/* 这个效果很棒，但我们怎样才能制作出多个不同比率的静态饼图呢？（这似乎才是更加常见的需求。）理想情况下，我们希望可以用这样的方式来
书写结构： 
<div class="pie">20%</div>
<div class="pie">60%</div>
然后就能得到两个饼图，一个展示为 20%，另一个展示为 60%。首先，我们需要探索如何用内联样式来实现这个需求；接下来，我们就可以写一小
段脚本来解析文本内容并把内联样式添加到元素上去，以实现代码的优雅性、封装抽象度、可维护性，以及（可能是）最重要的一点——可访问性。
用内联样式来控制饼图的比率带来了一个很大的挑战：这些负责设置比率的 CSS 代码最终是要应用到伪元素身上的。你可能已经知道了，我们无
法为伪元素设置内联样式，因此还要开动脑筋寻找对策。
*/
