/* 几年前，在刚刚获得 :nth-child()/:nth-of-type() 伪类之后，我们最常用其来解决的一个需求就是表格的“斑马条纹”。这在以
前需要服务器端预先处理、客户端的脚本处理或者是纯手工写死来实现，而现在只需下面这几行简单的代码就足够了： */
/* tr:nth-child(even) {
  background: rgba(0,0,0,.2);
} */

/* 尽管如此，当我们想把表格行的这种效果应用到文本行时，仍然有些力不从心。这种效果对于提高代码段的可读性来说尤为实用。很多开发者
最终不得不使用 JavaScript 来把每行代码包裹进一个个 <div> 元素中，然后运用上述 :nth-child() 技巧来实现斑马条纹——幸好大多数语法
着色脚本都可以顺带消化掉这个令人头皮发麻的过程。这种方式并不理想，它不仅在理论上有违纯粹原则（JavaScript 不应该掺和到样式层面来），
而且过多的DOM元素还会拖累整个页面的性能；此外，它其实不太健壮。（当你增大字号导致其中的某一“行”发生折行时会怎么样？）我们还有更好
的办法吗？ */
/* 抛开以前那种给每一行套元素再加背景的做法，我们换一种思路来重新考虑这个问题。为什么不对整个元素设置统一的背景图像，一次性加上所
有的斑马条纹呢？乍听起来这好像是个糟糕的点子，但别忘了，我们可以在CSS 中用渐变直接生成背景图像，而且可以用 em 单位来设定背景尺寸，
这样背景就可以自动适应 font-size 的变化了。让我们用这个方法给这段代码加上斑马条纹。首先，我们需要运用“条纹背景”一节中所描述的方法
，创建出水平条纹背景。它的background-size 需要设置为 line-height 的两倍，因为每个背景贴片需要覆盖两行代码。我们最初尝试写出的代
码可能是这样的： */
/* 让我们用这个方法给这段代码加上斑马条纹。首先，我们需要运用“条纹背景”一节中所描述的方法，创建出水平条纹背景。它的background-size
 需要设置为 line-height 的两倍，因为每个背景贴片需要覆盖两行代码。我们最初尝试写出的代码可能是这样的： */
.root {
  padding: .5em;
  line-height: 1.5;
  background: beige;
  background-image: linear-gradient(
   rgba(0,0,0,.2) 50%, transparent 0);
  background-size: auto 3em;
  white-space: pre-wrap;
}

/* 这个结果跟我们的预期已经相当接近了。我们甚至可以试着改变字号，条纹也会跟着放大或缩小！不过，有一个严肃的小问题不可忽视：代码行
和条纹是错位的，破坏了整体效果。这是怎么回事？如果近距离地观察，你可能就会发现，第一条条纹是从容器的最顶部开始的，这是背景图像最平
常的表现。不过，我们的代码并不是从那里开始的，因为那样排版会显得很局促。如你所见，我们对容器应用了 .5em 的内边距，这个距离正是这些
条纹与理想位置之间的偏差。有一个办法可以解决这个问题，那就是用 background-position 把向条纹向底部移动 .5em。不过，如果我们以后决
定调整内边距，还需要相应地修改背景定位值，这显然不够 DRY。可以让背景自动跟着内边距的宽度走吗？
 */
/* 让我们回顾一下“灵活的背景定位”中提到的 background-origin。这个属性正是我们所需要的：它可以告诉浏览器在解析 background-position
时以 content box 的外沿作为基准，而不是默认的 padding box 外沿。现在把
*/
.root {
  padding: .5em;
  line-height: 1.5;
  background: beige;
  background-origin: content-box;
  background-image: linear-gradient(
   rgba(0,0,0,.2) 50%, transparent 0);
  background-size: auto 3em;
  white-space: pre-wrap;
}
/* 这段样式正好可以达成我们想要的斑马条纹效果！因为我们是用半透明色来生成条纹的，所以在改变背景色时，斑马条纹仍然可以正常显示。
这个方法总体来说是十分灵活的，唯一可能破坏效果的情况②可能就是在改变 line-height 时忘了相应地调整 background-size */