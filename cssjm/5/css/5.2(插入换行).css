/* 通过 CSS 来插入换行的需求通常与定义列表有关，但有时也涉及其他场景。在通常情况下，采用定义列表是因为我们立志在互联网上以
身作则，坚持使用合适的标签、合理的语义——哪怕在视觉上所要呈现的只是一行行的名值对，我们也会认真对待。举例来说，考虑下面这段结
构代码：*/
/* 第一步通常是给它添加一些基本的 CSS： */
dd {
  margin: 0;
  font-weight: bold;
}
/* 不过，由于这些 <dt> 和 <dd> 都是块级元素，我们最终得到的往往这样的结果，所有的名和值均独占一行。我们接下来可能会给这
些 <dt> 或 <dd> 元素（或两者）指定其他的 display 属性值——人们走投无路时往往会胡乱尝试。不过这样一来，我们得到的结果通常
也是不对的，在我们把头发揪光、咒骂 CSS 或者干脆放弃结构与样式分离转而修改结构之前，有没有办法可以同时保全我们的神智和（技
术上的）操守？（哈哈哈哈qwq） */
/* 基本上，我们需要做的只是在每个 <dd> 后面添加一个换行。如果不在乎使用表现型的结构标记，可以请出老套的 <br> 元素，比如这样 */
/* 
  <!-- 如果你这样写，天崩地裂万劫不复 --> 
  <dt>Name:</dt>
  <dd>Lea Verou<br /></dd>
*/
/* 然后，对所有的 <dt> 和 <dd> 元素应用 display:inline; 样式，基本上就大功告成了。当然，这种方法不仅在可维护性方面是一种糟
糕的实践而且污染了结构层的代码。只要能使用生成性内容来添加换行，并以此取代<br> 元素，那么问题就可以解决了！但这好像做不到，对
吧？又或者，这其实可行的？ */
/* 实际上，有一个 Unicode 字符是专门代表换行符的：0x000A 。在 CSS 中，这个字符可以写作 "\000A"，或简化为 "\A"。我们可以用它
来作为 ::after伪元素的内容，并将其添加到每个 <dd> 元素的尾部，代码如下所示： */
/* dd::after {
  content: "\A";
} */
/* 这段代码看起来是可以奏效的，但如果我们亲手试一试，就会发现结果令人失望：没有任何变化。不过，这并不表示我们的思路不对，只是表示
我们还忽略了什么。这段 CSS 代码所做的其实只相当于在 HTML 结构中的所有关闭标签 </dd> 之前添加换行符。还记得在 HTML 代码中输入换行
符会发生什么吗？默认情况下，这些换行符会与相邻的其他空白符进行合并。空白符合并通常是一件非常好的事情，否则我们就得把整个 HTML 文档
的源代码整理进一行里面！不过，有时候我们希望保留源代码中的这些空白符和换行，代码块就是最典型的例子。还记得我们在这种场景下通常会怎
么做吗？我们会用到 white-space: pre;。这里也可以这么做，但只对伪元素生成的换行符设置这个样式。我们只有一个换行符，并不用担心有其他
空白符被保留下来（因为这里根本就没有），因此任何 pre 值都可以起作用（pre、pre-line 或 prewrap）。我推荐 pre，因为它的浏览器支持程
度最好。把这些思路整理成代码： */
/* dt, dd { display: inline; }
dd {
 margin: 0;
 font-weight: bold;
}
dd::after {
 content: "\A";
 white-space: pre;
} */
/* 如果你亲手测试一下，就会发现这个办法真的有效.不过，这种方法足够健壮吗？假设我们要给定义列表中的这位用户添加第二个邮箱 */
/* 结果有些莫名其妙。由于我们在每个 <dd> 的后面都加了一个换行符，每个值都会被分到单独一行中，甚至在不需要换行的时候也是如此。如果多
个并列的值以逗号分隔并且排在同一行中（假设容器的宽度足够），就会好得多了。在理想情况下，我们只想针对 <dt> 之前的最后一个 <dd>来插入
换行，而不是对所有的 <dd> 都这样做。不过，这对于当前 CSS 选择符的功能来说还是不可能的，因为选择符无法做到先在 DOM 树中选中主体元素，
再倒回去查询它之前的元素。我们需要换种方式来思考。一个想法就是换行符不用加在 <dd> 的后面，而是加在 <dt> 的前面： */
dt, dd { display: inline; }
/* dt::before {
  content: '\A';
  white-space: pre;
} */
/* 这会导致第一行变为空行，因为选择符对第一个 <dt> 也是生效的。为了规避这个问题，可以尝试使用以下这些选择符来替代单纯的 dt */
/* 
dt:not(:first-child)
dt ~ dt
dd + dt
*/
dd + dt::before {
  content: '\A';
  white-space: pre; 
}
/* 我们将采用最后一种方案，因为即使是在多个 <dt> 共用同一个值的场景下，它也是可以正常工作的；而另外两者在这种情况下还是会出问题。有
些时候，我们可能还是需要把多个 <dd> 显式分隔开，除非我们觉得多个值以空格作为分隔是可以接受的（这种方式在某些时候表现良好，但有时 */
